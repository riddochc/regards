= regards
Chris Riddoch <riddochc@gmail.com>
:language: ruby
:homepage: https://github.com/riddochc/regards
:revnumber: 0.0.1
:revdate: 2017-08-07

== Description

Regards are like facets - a collection of utility functions, to refine with.

Regards is a library of utility functions, in the style of the facets gem.
Being implemented as refinements, these can modify core ruby classes for the duration of the file they're used in, without causing conflicts in other code.
Become more refined by having regards, not concerns.

== Requirements

* Ruby

== Installation

gem install regards

== Use

An example use:

----
# Add the number? method to the String class:
require "regards/string/to_numeric"
using Regards::StringRefinements::Numeric

# Test whether some strings are numbers
["a", "73", "*"].map {|s| s.number? } # => [false, true, false]
----

If you run +pry+ or another REPL, you may encounter an error if you try +using+ the refinement:

----
RuntimeError: main.using is permitted only at toplevel
from (pry):1:in `using'
----

Unfortunately, this is hard to work around. Placing the +using+ statement in your +~/.pryrc+ is insufficient, as is evaluating it when pry starts with the +-e+ parameter.

As YARD currently does not index refinements, documentation for each submodule of the +Regards+ module follows.

=== StringRefinements::Numeric

Refines the String class with the following methods:

number?:: Returns true if the string can be converted to a number, false otherwise. Uses to_numeric.
to_numeric:: For strings representing numbers, returns an appropriate +Integer+, +Float+, +Rational+, +Complex+, +Float::INFINITY+, +Float::-INFINITY+, +Float::NaN+ (when the string is exactly "NaN"), or +Complex+. For any other string, returns nil.

=== StringRefinements::Unhexdump

Refines the String class with the following methods:

unhexdump:: Returns a binary string based on the value of hexadecimal characters in the current string.  Ignores whitespace, returns nil on strings with any non-hexadecimal, non-whitespace characters.

=== StringRefinements::Rewrite

Refines the string class with the following methods:

rewrite:: Takes a hash of regexes for keys and callable objects as values. Creates an edited version of the string by using the callable to create a new version of the string for each matching regex.  Think of it as grouping up repeated calls to +.sub()+ into one method.

Example:

----
subs= { /foo/ => ->(m) { m.pre_match + "blah" + m.post_match },
        /bar/ => ->(m) { m.pre_match + "baz" + m.post_match } }

"one foo for a bar plz".rewrite(subs)
# => "one blah for a baz plz"
----

rewrite_all:: Continues applying +rewrite()+ to the string until the string is left unchanged by further calls to +rewrite()+.  +.rewrite()+ is to +.sub()+ as +.rewrite_all+ is to +.gsub()+. 

Note that +rewrite_all()+ can potentially loop infinitely if the edited version of the string continues to be matchable by the regexes!

Example:

----
subs = { /[aoeui]+/ => ->(m) { m.pre_match + m[0].upcase + m.post_match } }
"a test string".rewrite_all(subs)
# => "A tEst strIng"

subs = { /[aoeui]/  => ->(m) { m.pre_match + "(1)" + m.post_match },
         /[tsr]/    => ->(m) { m.pre_match + "[0]" + m.post_match } }
"a test string".rewrite_all(subs)
# => "(1) [0](1)[0][0] [0][0][0](1)ng"

subs = { /[aoeui]/  => ->(m) { m.post_match + "(1)" + m.pre_match },
         /[tsr]/    => ->(m) { m.post_match + "[0]" + m.pre_match } }
"a test string".rewrite_all(subs)
# => "[0]ng(1)[0] (1)[0](1)[0] [0][0]"
----

== Contributing

Please do!

You may submit a pull request at the project's github site or email patches to the maintainer.

Be courteous and professional. Criticize code, not people.

== Contributors

* Chris Riddoch

== License

Copyright Â© 2017 Chris Riddoch

This code is licensed under the GPLv3. See LICENSE for details.

